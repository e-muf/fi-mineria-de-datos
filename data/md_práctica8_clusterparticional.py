# -*- coding: utf-8 -*-
"""MD-Práctica8-ClusterParticional.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1sva2AfbrEq1VZQG6uKfPTe-qrEysLH-U

## **Práctica 8: Clustering (Segmentación)**

Nombre:

No. Cuenta:

Email:
"""

# Commented out IPython magic to ensure Python compatibility.
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns             #Para la visualización de datos basado en matplotlib
# %matplotlib inline

"""#### **Acceso a los datos**

Estudios clínicos a partir de imágenes digitalizadas de pacientes con cáncer de mama de Wisconsin (WDBC, Wisconsin Diagnostic Breast Cancer)

Fuente: https://archive.ics.uci.edu/ml/datasets/Breast+Cancer+Wisconsin+(Diagnostic)
"""

from google.colab import files
files.upload()

#from google.colab import drive
#drive.mount('/content/drive')

BCancer = pd.read_csv('WDBCOriginal.csv')
BCancer

print(BCancer.groupby('Diagnosis').size())

"""#### **Paso 1: Selección de características**

Se utiliza una matriz de correlaciones con el propósito de definir un grupo de características significativas.
"""

sns.pairplot(BCancer, hue='Diagnosis')
plt.show()

#plt.plot(BCancer['Radius'], BCancer['Perimeter'], 'b+')
sns.scatterplot(x='Radius', y ='Perimeter', data=BCancer, hue='Diagnosis')
plt.title('Gráfico de dispersión')
plt.xlabel('Radius')
plt.ylabel('Perimeter')
plt.show()

#plt.plot(BCancer['Concavity'], BCancer['ConcavePoints'], 'b+')
sns.scatterplot(x='Concavity', y ='ConcavePoints', data=BCancer, hue='Diagnosis')
plt.title('Gráfico de dispersión')
plt.xlabel('Concavity')
plt.ylabel('ConcavePoints')
plt.show()

CorrBCancer = BCancer.corr(method='pearson')
CorrBCancer

plt.figure(figsize=(14,7))
MatrizInf = np.triu(CorrBCancer)
sns.heatmap(CorrBCancer, cmap='RdBu_r', annot=True, mask=MatrizInf)
plt.show()

print(CorrBCancer['Radius'].sort_values(ascending=False)[:10], '\n')   #Top 10 valores

"""**Varibles seleccionadas:**

1) Textura [Posición 3]

2) Area [Posición 5]

3) Smoothness [Posición 6]

4) Compactness [Posición 7]

5) Symmetry [Posición 10]

6) FractalDimension [Posición 11]
"""

MatrizVariables = np.array(BCancer[['Texture', 'Area', 'Smoothness', 'Compactness', 'Symmetry', 'FractalDimension']])
#MatrizVariables = BCancer.iloc[:, [3, 5, 6, 7, 10, 11]].values  #iloc para seleccionar filas y columnas según su posición
pd.DataFrame(MatrizVariables)

MatrizActual = BCancer.drop(['IDNumber', 'Diagnosis', 'Radius', 'Perimeter', 'Concavity', 'ConcavePoints'], axis=1)
MatrizActual

"""### **Clustering particional**

Algoritmo: K-means
"""

#Se importan las bibliotecas
from sklearn.cluster import KMeans
from sklearn.metrics import pairwise_distances_argmin_min

#Definición de k clusters para K-means
#Se utiliza random_state para inicializar el generador interno de números aleatorios
SSE = []
for i in range(2, 12):
    km = KMeans(n_clusters=i, random_state=0)
    km.fit(MatrizVariables)
    SSE.append(km.inertia_)

#Se grafica SSE en función de k
plt.figure(figsize=(10, 7))
plt.plot(range(2, 12), SSE, marker='o')
plt.xlabel('Cantidad de clusters *k*')
plt.ylabel('SSE')
plt.title('Elbow Method')
plt.show()

!pip install kneed

from kneed import KneeLocator
kl = KneeLocator(range(2, 12), SSE, curve="convex", direction="decreasing")
kl.elbow

plt.style.use('ggplot')
kl.plot_knee()

#Se crean las etiquetas de los elementos en los clusters
MParticional = KMeans(n_clusters=5, random_state=0).fit(MatrizVariables)
MParticional.predict(MatrizVariables)
MParticional.labels_

BCancer['clusterP'] = MParticional.labels_
BCancer

BCancer.groupby(['clusterP'])['clusterP'].count()

plt.figure(figsize=(10, 7))
plt.scatter(MatrizVariables[:,0], MatrizVariables[:,1], c=MParticional.labels_, cmap='rainbow')
plt.show()

CentroidesP = MParticional.cluster_centers_
pd.DataFrame(CentroidesP.round(4), columns=['Texture', 'Area', 'Smoothness', 'Compactness', 'Symmetry', 'FractalDimension'])

"""**Cluster 0:** Conformado por 12 pacientes con alta probabilidad de cáncer maligno por el tamaño del tumor (cluster con mayores tamaños), con un área promedio de tumor de 1934 píxeles y una desviación estándar de textura de 22.5 píxeles. Aparentemente es un tumor compacto (0.19 píxeles), cuya suavidad alcanza 0.10 píxeles, una simetría de 0.19 y una aproximación de frontera, dimensión fractal, promedio de 0.06 píxeles.

**Cluster 1:** ...
"""

# Gráfica de los elementos y los centros de los clusters
from mpl_toolkits.mplot3d import Axes3D
plt.rcParams['figure.figsize'] = (10, 7)
plt.style.use('ggplot')
colores=['red', 'blue', 'cyan', 'green', 'yellow']
asignar=[]
for row in MParticional.labels_:
    asignar.append(colores[row])

fig = plt.figure()
ax = Axes3D(fig)
ax.scatter(MatrizVariables[:, 0], MatrizVariables[:, 1], MatrizVariables[:, 2], marker='o', c=asignar, s=60)
ax.scatter(CentroidesP[:, 0], CentroidesP[:, 1], CentroidesP[:, 2], marker='o', c=colores, s=1000)
plt.show()

#Es posible identificar los pacientes más cercanos a cada centroide
Cercanos,_ = pairwise_distances_argmin_min(MParticional.cluster_centers_, MatrizVariables)
Cercanos

Pacientes = BCancer['IDNumber'].values
for row in Cercanos:
    print(Pacientes[row])